{"ast":null,"code":"import{compute as t}from\"compute-scroll-into-view\";const o=t=>!1===t?{block:\"end\",inline:\"nearest\"}:(t=>t===Object(t)&&0!==Object.keys(t).length)(t)?t:{block:\"start\",inline:\"nearest\"};function e(e,r){if(!e.isConnected||!(t=>{let o=t;for(;o&&o.parentNode;){if(o.parentNode===document)return!0;o=o.parentNode instanceof ShadowRoot?o.parentNode.host:o.parentNode;}return!1;})(e))return;const n=(t=>{const o=window.getComputedStyle(t);return{top:parseFloat(o.scrollMarginTop)||0,right:parseFloat(o.scrollMarginRight)||0,bottom:parseFloat(o.scrollMarginBottom)||0,left:parseFloat(o.scrollMarginLeft)||0};})(e);if((t=>\"object\"==typeof t&&\"function\"==typeof t.behavior)(r))return r.behavior(t(e,r));const l=\"boolean\"==typeof r||null==r?void 0:r.behavior;for(const{el:a,top:i,left:s}of t(e,o(r))){const t=i-n.top+n.bottom,o=s-n.left+n.right;a.scroll({top:t,left:o,behavior:l});}}export{e as default};","map":{"version":3,"names":["o","t","block","inline","Object","keys","length","e","r","isConnected","parentNode","document","ShadowRoot","host","n","window","getComputedStyle","top","parseFloat","scrollMarginTop","right","scrollMarginRight","bottom","scrollMarginBottom","left","scrollMarginLeft","behavior","l","el","a","i","s","scroll","default"],"sources":["/Users/jmmallon/Downloads/js/ticketproject/src/node_modules/scroll-into-view-if-needed/src/index.ts"],"sourcesContent":["import { compute } from 'compute-scroll-into-view'\nimport type {\n  Options as BaseOptions,\n  ScrollAction,\n} from 'compute-scroll-into-view'\n\n/** @public */\nexport type Options<T = unknown> =\n  | StandardBehaviorOptions\n  | CustomBehaviorOptions<T>\n\n/**\n * Only scrolls if the `node` is partially out of view:\n * ```ts\n * scrollIntoView(node, { scrollMode: 'if-needed' })\n * ```\n * Skips scrolling `overflow: hidden` elements:\n * ```ts\n * scrollIntoView(node, { skipOverflowHiddenElements: true })\n * ```\n * When scrolling is needed do the least and smoothest scrolling possible:\n * ```ts\n * scrollIntoView(node, {\n *   behavior: 'smooth',\n *   scrollMode: 'if-needed',\n *   block: 'nearest',\n *   inline: 'nearest',\n * })\n * ```\n * @public\n */\nexport interface StandardBehaviorOptions extends BaseOptions {\n  /**\n   * @defaultValue 'auto\n   */\n  behavior?: ScrollBehavior\n}\n\n/** @public */\nexport interface CustomBehaviorOptions<T = unknown> extends BaseOptions {\n  behavior: CustomScrollBehaviorCallback<T>\n}\n\n/** @public */\nexport type CustomScrollBehaviorCallback<T = unknown> = (\n  actions: ScrollAction[]\n) => T\n\nconst isStandardScrollBehavior = (\n  options: any\n): options is StandardBehaviorOptions =>\n  options === Object(options) && Object.keys(options).length !== 0\n\nconst isCustomScrollBehavior = <T = unknown>(\n  options: any\n): options is CustomBehaviorOptions<T> =>\n  typeof options === 'object' ? typeof options.behavior === 'function' : false\n\nconst getOptions = (options: any): StandardBehaviorOptions => {\n  // Handle alignToTop for legacy reasons, to be compatible with the spec\n  if (options === false) {\n    return { block: 'end', inline: 'nearest' }\n  }\n\n  if (isStandardScrollBehavior(options)) {\n    // compute.ts ensures the defaults are block: 'center' and inline: 'nearest', to conform to the spec\n    return options\n  }\n\n  // if options = {}, options = true or options = null, based on w3c web platform test\n  return { block: 'start', inline: 'nearest' }\n}\n\nconst getScrollMargins = (target: Element) => {\n  const computedStyle = window.getComputedStyle(target)\n  return {\n    top: parseFloat(computedStyle.scrollMarginTop) || 0,\n    right: parseFloat(computedStyle.scrollMarginRight) || 0,\n    bottom: parseFloat(computedStyle.scrollMarginBottom) || 0,\n    left: parseFloat(computedStyle.scrollMarginLeft) || 0,\n  }\n}\n\n// Determine if the element is part of the document (including shadow dom)\n// Derived from code of Andy Desmarais\n// https://terodox.tech/how-to-tell-if-an-element-is-in-the-dom-including-the-shadow-dom/\nconst isInDocument = (element: Node) => {\n  let currentElement = element\n  while (currentElement && currentElement.parentNode) {\n    if (currentElement.parentNode === document) {\n      return true\n    } else if (currentElement.parentNode instanceof ShadowRoot) {\n      currentElement = (currentElement.parentNode as ShadowRoot).host\n    } else {\n      currentElement = currentElement.parentNode\n    }\n  }\n  return false\n}\n\n/**\n * Scrolls the given element into view, with options for when, and how.\n * Supports the same `options` as [`Element.prototype.scrollIntoView`](https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView) with additions such as `scrollMode`, `behavior: Function` and `skipOverflowHiddenElements`.\n * @public\n */\nfunction scrollIntoView(\n  target: Element,\n  options?: StandardBehaviorOptions | boolean\n): void\n/**\n * Scrolls the given element into view, with options for when, and how.\n * Supports the same `options` as [`Element.prototype.scrollIntoView`](https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView) with additions such as `scrollMode`, `behavior: Function` and `skipOverflowHiddenElements`.\n *\n * You can set the expected return type for `behavior: Function`:\n * ```ts\n * await scrollIntoView<Promise<boolean[]>>(node, {\n *   behavior: async actions => {\n *     return Promise.all(actions.map(\n *       // animate() resolves to `true` if anything was animated, `false` if the element already were in the end state\n *       ({ el, left, top }) => animate(el, {scroll: {left, top}})\n *     ))\n *   }\n * })\n * ```\n * @public\n */\nfunction scrollIntoView<T>(\n  target: Element,\n  options: CustomBehaviorOptions<T>\n): T\nfunction scrollIntoView<T = unknown>(\n  target: Element,\n  options?: StandardBehaviorOptions | CustomBehaviorOptions<T> | boolean\n): T | void {\n  // Browsers treats targets that aren't in the dom as a no-op and so should we\n  if (!target.isConnected || !isInDocument(target)) {\n    return\n  }\n\n  const margins = getScrollMargins(target)\n\n  if (isCustomScrollBehavior<T>(options)) {\n    return options.behavior(compute(target, options))\n  }\n\n  const behavior = typeof options === 'boolean' ? undefined : options?.behavior\n\n  for (const { el, top, left } of compute(target, getOptions(options))) {\n    const adjustedTop = top - margins.top + margins.bottom\n    const adjustedLeft = left - margins.left + margins.right\n    el.scroll({ top: adjustedTop, left: adjustedLeft, behavior })\n  }\n}\n\nexport default scrollIntoView\n"],"mappings":"mDAgDA,KAUM,CAAAA,CAAA,CAAcC,CAAA,GAEF,IAAZA,CAAA,CACK,CAAEC,KAAA,CAAO,MAAOC,MAAA,CAAQ,WAZjC,CAAAF,CAAA,EAEAA,CAAA,GAAYG,MAAA,CAAOH,CAAA,GAA4C,IAAhCG,MAAA,CAAOC,IAAA,CAAKJ,CAAA,EAASK,MAAA,EAavBL,CAAA,EAEpBA,CAAA,CAIF,CAAEC,KAAA,CAAO,QAASC,MAAA,CAAQ,WA4DnC,QAAS,CAAAI,EACPA,CAAA,CACAC,CAAA,EAGA,IAAKD,CAAA,CAAOE,WAAA,GAjDQ,CAAAR,CAAA,GACpB,GAAI,CAAAD,CAAA,CAAiBC,CAAA,CACd,KAAAD,CAAA,EAAkBA,CAAA,CAAeU,UAAA,EAAY,CAC9C,GAAAV,CAAA,CAAeU,UAAA,GAAeC,QAAA,CACzB,SAEPX,CAAA,CADSA,CAAA,CAAeU,UAAA,WAAsB,CAAAE,UAAA,CAC5BZ,CAAA,CAAeU,UAAA,CAA0BG,IAAA,CAE1Cb,CAAA,CAAeU,UAEpC,EACO,YAsCkCH,CAAA,EACvC,OAGI,MAAAO,CAAA,CAlEkB,CAAAb,CAAA,GAClB,MAAAD,CAAA,CAAgBe,MAAA,CAAOC,gBAAA,CAAiBf,CAAA,EACvC,OACLgB,GAAA,CAAKC,UAAA,CAAWlB,CAAA,CAAcmB,eAAA,GAAoB,EAClDC,KAAA,CAAOF,UAAA,CAAWlB,CAAA,CAAcqB,iBAAA,GAAsB,EACtDC,MAAA,CAAQJ,UAAA,CAAWlB,CAAA,CAAcuB,kBAAA,GAAuB,EACxDC,IAAA,CAAMN,UAAA,CAAWlB,CAAA,CAAcyB,gBAAA,GAAqB,EACtD,IA2DiClB,CAAA,EAE7B,GAvFJ,CAAAN,CAAA,EAEmB,gBAAZ,CAAAA,CAAA,EAAmD,kBAArB,CAAAA,CAAA,CAAQyB,QAAA,EAqFflB,CAAA,EAC5B,MAAO,CAAAA,CAAA,CAAQkB,QAAA,CAASzB,CAAA,CAAQM,CAAA,CAAQC,CAAA,GAG1C,KAAM,CAAAmB,CAAA,CAA8B,iBAAZ,CAAAnB,CAAA,EAA6C,MAATA,CAAA,KAAZ,GAAqBA,CAAA,CAAAkB,QAAA,CAE1D,UAAAE,EAAA,CAAEC,CAAA,CAAIZ,GAAA,CAAAa,CAAA,CAAAN,IAAA,CAAKO,CAAA,GAAU,CAAA9B,CAAA,CAAQM,CAAA,CAAQP,CAAA,CAAWQ,CAAA,GAAW,CACpE,KAAM,CAAAP,CAAA,CAAc6B,CAAA,CAAMhB,CAAA,CAAQG,GAAA,CAAMH,CAAA,CAAQQ,MAAA,CAC1CtB,CAAA,CAAe+B,CAAA,CAAOjB,CAAA,CAAQU,IAAA,CAAOV,CAAA,CAAQM,KAAA,CACnDS,CAAA,CAAGG,MAAA,CAAO,CAAEf,GAAA,CAAKhB,CAAA,CAAauB,IAAA,CAAMxB,CAAA,CAAc0B,QAAA,CAAAC,CAAA,EACpD,EACF,QAAApB,CAAA,IAAA0B,OAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}