{"ast":null,"code":"var _s = $RefreshSig$();\nimport * as React from 'react';\nimport { groupKeysMap } from '../../_util/transKeys';\nconst useData = (dataSource, rowKey, targetKeys) => {\n  _s();\n  const mergedDataSource = React.useMemo(() => (dataSource || []).map(record => {\n    if (rowKey) {\n      record = Object.assign(Object.assign({}, record), {\n        key: rowKey(record)\n      });\n    }\n    return record;\n  }), [dataSource, rowKey]);\n  const [leftDataSource, rightDataSource] = React.useMemo(() => {\n    const leftData = [];\n    const rightData = new Array((targetKeys || []).length);\n    const targetKeysMap = groupKeysMap(targetKeys || []);\n    mergedDataSource.forEach(record => {\n      // rightData should be ordered by targetKeys\n      // leftData should be ordered by dataSource\n      if (targetKeysMap.has(record.key)) {\n        rightData[targetKeysMap.get(record.key)] = record;\n      } else {\n        leftData.push(record);\n      }\n    });\n    return [leftData, rightData];\n  }, [mergedDataSource, targetKeys, rowKey]);\n  return [mergedDataSource, leftDataSource, rightDataSource];\n};\n_s(useData, \"08EfuF+iN3r9Y4r8wMR/eA5qCnc=\");\nexport default useData;","map":{"version":3,"names":["React","groupKeysMap","useData","dataSource","rowKey","targetKeys","_s","mergedDataSource","useMemo","map","record","Object","assign","key","leftDataSource","rightDataSource","leftData","rightData","Array","length","targetKeysMap","forEach","has","get","push"],"sources":["/Users/jmmallon/git/a/AlamedaFoodBankTicketSystem/FrontEnd/ticketing-frontend/src/node_modules/antd/es/transfer/hooks/useData.js"],"sourcesContent":["import * as React from 'react';\nimport { groupKeysMap } from '../../_util/transKeys';\nconst useData = (dataSource, rowKey, targetKeys) => {\n  const mergedDataSource = React.useMemo(() => (dataSource || []).map(record => {\n    if (rowKey) {\n      record = Object.assign(Object.assign({}, record), {\n        key: rowKey(record)\n      });\n    }\n    return record;\n  }), [dataSource, rowKey]);\n  const [leftDataSource, rightDataSource] = React.useMemo(() => {\n    const leftData = [];\n    const rightData = new Array((targetKeys || []).length);\n    const targetKeysMap = groupKeysMap(targetKeys || []);\n    mergedDataSource.forEach(record => {\n      // rightData should be ordered by targetKeys\n      // leftData should be ordered by dataSource\n      if (targetKeysMap.has(record.key)) {\n        rightData[targetKeysMap.get(record.key)] = record;\n      } else {\n        leftData.push(record);\n      }\n    });\n    return [leftData, rightData];\n  }, [mergedDataSource, targetKeys, rowKey]);\n  return [mergedDataSource, leftDataSource, rightDataSource];\n};\nexport default useData;"],"mappings":";AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAC9B,SAASC,YAAY,QAAQ,uBAAuB;AACpD,MAAMC,OAAO,GAAGA,CAACC,UAAU,EAAEC,MAAM,EAAEC,UAAU,KAAK;EAAAC,EAAA;EAClD,MAAMC,gBAAgB,GAAGP,KAAK,CAACQ,OAAO,CAAC,MAAM,CAACL,UAAU,IAAI,EAAE,EAAEM,GAAG,CAACC,MAAM,IAAI;IAC5E,IAAIN,MAAM,EAAE;MACVM,MAAM,GAAGC,MAAM,CAACC,MAAM,CAACD,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEF,MAAM,CAAC,EAAE;QAChDG,GAAG,EAAET,MAAM,CAACM,MAAM;MACpB,CAAC,CAAC;IACJ;IACA,OAAOA,MAAM;EACf,CAAC,CAAC,EAAE,CAACP,UAAU,EAAEC,MAAM,CAAC,CAAC;EACzB,MAAM,CAACU,cAAc,EAAEC,eAAe,CAAC,GAAGf,KAAK,CAACQ,OAAO,CAAC,MAAM;IAC5D,MAAMQ,QAAQ,GAAG,EAAE;IACnB,MAAMC,SAAS,GAAG,IAAIC,KAAK,CAAC,CAACb,UAAU,IAAI,EAAE,EAAEc,MAAM,CAAC;IACtD,MAAMC,aAAa,GAAGnB,YAAY,CAACI,UAAU,IAAI,EAAE,CAAC;IACpDE,gBAAgB,CAACc,OAAO,CAACX,MAAM,IAAI;MACjC;MACA;MACA,IAAIU,aAAa,CAACE,GAAG,CAACZ,MAAM,CAACG,GAAG,CAAC,EAAE;QACjCI,SAAS,CAACG,aAAa,CAACG,GAAG,CAACb,MAAM,CAACG,GAAG,CAAC,CAAC,GAAGH,MAAM;MACnD,CAAC,MAAM;QACLM,QAAQ,CAACQ,IAAI,CAACd,MAAM,CAAC;MACvB;IACF,CAAC,CAAC;IACF,OAAO,CAACM,QAAQ,EAAEC,SAAS,CAAC;EAC9B,CAAC,EAAE,CAACV,gBAAgB,EAAEF,UAAU,EAAED,MAAM,CAAC,CAAC;EAC1C,OAAO,CAACG,gBAAgB,EAAEO,cAAc,EAAEC,eAAe,CAAC;AAC5D,CAAC;AAACT,EAAA,CAzBIJ,OAAO;AA0Bb,eAAeA,OAAO","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}