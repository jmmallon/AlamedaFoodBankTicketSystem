{"ast":null,"code":"/* eslint-disable no-undefined,no-param-reassign,no-shadow */ /**\n * Throttle execution of a function. Especially useful for rate limiting\n * execution of handlers on events like resize and scroll.\n *\n * @param {number} delay -                  A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher)\n *                                            are most useful.\n * @param {Function} callback -               A function to be executed after delay milliseconds. The `this` context and all arguments are passed through,\n *                                            as-is, to `callback` when the throttled-function is executed.\n * @param {object} [options] -              An object to configure options.\n * @param {boolean} [options.noTrailing] -   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds\n *                                            while the throttled-function is being called. If noTrailing is false or unspecified, callback will be executed\n *                                            one final time after the last throttled-function call. (After the throttled-function has not been called for\n *                                            `delay` milliseconds, the internal counter is reset).\n * @param {boolean} [options.noLeading] -   Optional, defaults to false. If noLeading is false, the first throttled-function call will execute callback\n *                                            immediately. If noLeading is true, the first the callback execution will be skipped. It should be noted that\n *                                            callback will never executed if both noLeading = true and noTrailing = true.\n * @param {boolean} [options.debounceMode] - If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is\n *                                            false (at end), schedule `callback` to execute after `delay` ms.\n *\n * @returns {Function} A new, throttled, function.\n */function throttle(delay,callback,options){var _ref=options||{},_ref$noTrailing=_ref.noTrailing,noTrailing=_ref$noTrailing===void 0?false:_ref$noTrailing,_ref$noLeading=_ref.noLeading,noLeading=_ref$noLeading===void 0?false:_ref$noLeading,_ref$debounceMode=_ref.debounceMode,debounceMode=_ref$debounceMode===void 0?undefined:_ref$debounceMode;/*\n   * After wrapper has stopped being called, this timeout ensures that\n   * `callback` is executed at the proper times in `throttle` and `end`\n   * debounce modes.\n   */var timeoutID;var cancelled=false;// Keep track of the last time `callback` was executed.\nvar lastExec=0;// Function to clear existing timeout\nfunction clearExistingTimeout(){if(timeoutID){clearTimeout(timeoutID);}}// Function to cancel next exec\nfunction cancel(options){var _ref2=options||{},_ref2$upcomingOnly=_ref2.upcomingOnly,upcomingOnly=_ref2$upcomingOnly===void 0?false:_ref2$upcomingOnly;clearExistingTimeout();cancelled=!upcomingOnly;}/*\n   * The `wrapper` function encapsulates all of the throttling / debouncing\n   * functionality and when executed will limit the rate at which `callback`\n   * is executed.\n   */function wrapper(){for(var _len=arguments.length,arguments_=new Array(_len),_key=0;_key<_len;_key++){arguments_[_key]=arguments[_key];}var self=this;var elapsed=Date.now()-lastExec;if(cancelled){return;}// Execute `callback` and update the `lastExec` timestamp.\nfunction exec(){lastExec=Date.now();callback.apply(self,arguments_);}/*\n     * If `debounceMode` is true (at begin) this is used to clear the flag\n     * to allow future `callback` executions.\n     */function clear(){timeoutID=undefined;}if(!noLeading&&debounceMode&&!timeoutID){/*\n       * Since `wrapper` is being called for the first time and\n       * `debounceMode` is true (at begin), execute `callback`\n       * and noLeading != true.\n       */exec();}clearExistingTimeout();if(debounceMode===undefined&&elapsed>delay){if(noLeading){/*\n         * In throttle mode with noLeading, if `delay` time has\n         * been exceeded, update `lastExec` and schedule `callback`\n         * to execute after `delay` ms.\n         */lastExec=Date.now();if(!noTrailing){timeoutID=setTimeout(debounceMode?clear:exec,delay);}}else{/*\n         * In throttle mode without noLeading, if `delay` time has been exceeded, execute\n         * `callback`.\n         */exec();}}else if(noTrailing!==true){/*\n       * In trailing throttle mode, since `delay` time has not been\n       * exceeded, schedule `callback` to execute `delay` ms after most\n       * recent execution.\n       *\n       * If `debounceMode` is true (at begin), schedule `clear` to execute\n       * after `delay` ms.\n       *\n       * If `debounceMode` is false (at end), schedule `callback` to\n       * execute after `delay` ms.\n       */timeoutID=setTimeout(debounceMode?clear:exec,debounceMode===undefined?delay-elapsed:delay);}}wrapper.cancel=cancel;// Return the wrapper function.\nreturn wrapper;}/* eslint-disable no-undefined */ /**\n * Debounce execution of a function. Debouncing, unlike throttling,\n * guarantees that a function is only executed a single time, either at the\n * very beginning of a series of calls, or at the very end.\n *\n * @param {number} delay -               A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\n * @param {Function} callback -          A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,\n *                                        to `callback` when the debounced-function is executed.\n * @param {object} [options] -           An object to configure options.\n * @param {boolean} [options.atBegin] -  Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds\n *                                        after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.\n *                                        (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).\n *\n * @returns {Function} A new, debounced function.\n */function debounce(delay,callback,options){var _ref=options||{},_ref$atBegin=_ref.atBegin,atBegin=_ref$atBegin===void 0?false:_ref$atBegin;return throttle(delay,callback,{debounceMode:atBegin!==false});}export{debounce,throttle};","map":{"version":3,"names":["throttle","delay","callback","options","_ref","_ref$noTrailing","noTrailing","_ref$noLeading","noLeading","_ref$debounceMode","debounceMode","undefined","timeoutID","cancelled","lastExec","clearExistingTimeout","clearTimeout","cancel","_ref2","_ref2$upcomingOnly","upcomingOnly","wrapper","_len","arguments","length","arguments_","Array","_key","self","elapsed","Date","now","exec","apply","clear","setTimeout","debounce","_ref$atBegin","atBegin"],"sources":["/Users/jmmallon/Downloads/js/ticketproject/src/node_modules/throttle-debounce/throttle.js","/Users/jmmallon/Downloads/js/ticketproject/src/node_modules/throttle-debounce/debounce.js"],"sourcesContent":["/* eslint-disable no-undefined,no-param-reassign,no-shadow */\n\n/**\n * Throttle execution of a function. Especially useful for rate limiting\n * execution of handlers on events like resize and scroll.\n *\n * @param {number} delay -                  A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher)\n *                                            are most useful.\n * @param {Function} callback -               A function to be executed after delay milliseconds. The `this` context and all arguments are passed through,\n *                                            as-is, to `callback` when the throttled-function is executed.\n * @param {object} [options] -              An object to configure options.\n * @param {boolean} [options.noTrailing] -   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds\n *                                            while the throttled-function is being called. If noTrailing is false or unspecified, callback will be executed\n *                                            one final time after the last throttled-function call. (After the throttled-function has not been called for\n *                                            `delay` milliseconds, the internal counter is reset).\n * @param {boolean} [options.noLeading] -   Optional, defaults to false. If noLeading is false, the first throttled-function call will execute callback\n *                                            immediately. If noLeading is true, the first the callback execution will be skipped. It should be noted that\n *                                            callback will never executed if both noLeading = true and noTrailing = true.\n * @param {boolean} [options.debounceMode] - If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is\n *                                            false (at end), schedule `callback` to execute after `delay` ms.\n *\n * @returns {Function} A new, throttled, function.\n */\nexport default function (delay, callback, options) {\n\tconst {\n\t\tnoTrailing = false,\n\t\tnoLeading = false,\n\t\tdebounceMode = undefined\n\t} = options || {};\n\t/*\n\t * After wrapper has stopped being called, this timeout ensures that\n\t * `callback` is executed at the proper times in `throttle` and `end`\n\t * debounce modes.\n\t */\n\tlet timeoutID;\n\tlet cancelled = false;\n\n\t// Keep track of the last time `callback` was executed.\n\tlet lastExec = 0;\n\n\t// Function to clear existing timeout\n\tfunction clearExistingTimeout() {\n\t\tif (timeoutID) {\n\t\t\tclearTimeout(timeoutID);\n\t\t}\n\t}\n\n\t// Function to cancel next exec\n\tfunction cancel(options) {\n\t\tconst { upcomingOnly = false } = options || {};\n\t\tclearExistingTimeout();\n\t\tcancelled = !upcomingOnly;\n\t}\n\n\t/*\n\t * The `wrapper` function encapsulates all of the throttling / debouncing\n\t * functionality and when executed will limit the rate at which `callback`\n\t * is executed.\n\t */\n\tfunction wrapper(...arguments_) {\n\t\tlet self = this;\n\t\tlet elapsed = Date.now() - lastExec;\n\n\t\tif (cancelled) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Execute `callback` and update the `lastExec` timestamp.\n\t\tfunction exec() {\n\t\t\tlastExec = Date.now();\n\t\t\tcallback.apply(self, arguments_);\n\t\t}\n\n\t\t/*\n\t\t * If `debounceMode` is true (at begin) this is used to clear the flag\n\t\t * to allow future `callback` executions.\n\t\t */\n\t\tfunction clear() {\n\t\t\ttimeoutID = undefined;\n\t\t}\n\n\t\tif (!noLeading && debounceMode && !timeoutID) {\n\t\t\t/*\n\t\t\t * Since `wrapper` is being called for the first time and\n\t\t\t * `debounceMode` is true (at begin), execute `callback`\n\t\t\t * and noLeading != true.\n\t\t\t */\n\t\t\texec();\n\t\t}\n\n\t\tclearExistingTimeout();\n\n\t\tif (debounceMode === undefined && elapsed > delay) {\n\t\t\tif (noLeading) {\n\t\t\t\t/*\n\t\t\t\t * In throttle mode with noLeading, if `delay` time has\n\t\t\t\t * been exceeded, update `lastExec` and schedule `callback`\n\t\t\t\t * to execute after `delay` ms.\n\t\t\t\t */\n\t\t\t\tlastExec = Date.now();\n\t\t\t\tif (!noTrailing) {\n\t\t\t\t\ttimeoutID = setTimeout(debounceMode ? clear : exec, delay);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * In throttle mode without noLeading, if `delay` time has been exceeded, execute\n\t\t\t\t * `callback`.\n\t\t\t\t */\n\t\t\t\texec();\n\t\t\t}\n\t\t} else if (noTrailing !== true) {\n\t\t\t/*\n\t\t\t * In trailing throttle mode, since `delay` time has not been\n\t\t\t * exceeded, schedule `callback` to execute `delay` ms after most\n\t\t\t * recent execution.\n\t\t\t *\n\t\t\t * If `debounceMode` is true (at begin), schedule `clear` to execute\n\t\t\t * after `delay` ms.\n\t\t\t *\n\t\t\t * If `debounceMode` is false (at end), schedule `callback` to\n\t\t\t * execute after `delay` ms.\n\t\t\t */\n\t\t\ttimeoutID = setTimeout(\n\t\t\t\tdebounceMode ? clear : exec,\n\t\t\t\tdebounceMode === undefined ? delay - elapsed : delay\n\t\t\t);\n\t\t}\n\t}\n\n\twrapper.cancel = cancel;\n\n\t// Return the wrapper function.\n\treturn wrapper;\n}\n","/* eslint-disable no-undefined */\n\nimport throttle from './throttle.js';\n\n/**\n * Debounce execution of a function. Debouncing, unlike throttling,\n * guarantees that a function is only executed a single time, either at the\n * very beginning of a series of calls, or at the very end.\n *\n * @param {number} delay -               A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\n * @param {Function} callback -          A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,\n *                                        to `callback` when the debounced-function is executed.\n * @param {object} [options] -           An object to configure options.\n * @param {boolean} [options.atBegin] -  Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds\n *                                        after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.\n *                                        (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).\n *\n * @returns {Function} A new, debounced function.\n */\nexport default function (delay, callback, options) {\n\tconst { atBegin = false } = options || {};\n\treturn throttle(delay, callback, { debounceMode: atBegin !== false });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}