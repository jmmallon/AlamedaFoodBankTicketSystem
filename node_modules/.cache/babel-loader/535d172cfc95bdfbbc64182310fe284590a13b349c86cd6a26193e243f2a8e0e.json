{"ast":null,"code":"\"use client\";\n\nvar _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport * as React from 'react';\nimport toArray from \"rc-util/es/Children/toArray\";\nimport useLayoutEffect from \"rc-util/es/hooks/useLayoutEffect\";\nconst MeasureText = /*#__PURE__*/_s( /*#__PURE__*/React.forwardRef(_c = _s((_ref, ref) => {\n  _s();\n  let {\n    style,\n    children\n  } = _ref;\n  const spanRef = React.useRef(null);\n  React.useImperativeHandle(ref, () => ({\n    isExceed: () => {\n      const span = spanRef.current;\n      return span.scrollHeight > span.clientHeight;\n    },\n    getHeight: () => spanRef.current.clientHeight\n  }));\n  return /*#__PURE__*/React.createElement(\"span\", {\n    \"aria-hidden\": true,\n    ref: spanRef,\n    style: Object.assign({\n      position: 'fixed',\n      display: 'block',\n      left: 0,\n      top: 0,\n      // zIndex: -9999,\n      // visibility: 'hidden',\n      pointerEvents: 'none',\n      backgroundColor: 'rgba(255, 0, 0, 0.65)'\n    }, style)\n  }, children);\n}, \"RlmKc5JgjGnLkrRosVCtEIr+OBI=\")), \"RlmKc5JgjGnLkrRosVCtEIr+OBI=\");\n_c2 = MeasureText;\nfunction cuttable(node) {\n  const type = typeof node;\n  return type === 'string' || type === 'number';\n}\nfunction getNodesLen(nodeList) {\n  let totalLen = 0;\n  nodeList.forEach(node => {\n    if (cuttable(node)) {\n      totalLen += String(node).length;\n    } else {\n      totalLen += 1;\n    }\n  });\n  return totalLen;\n}\nfunction sliceNodes(nodeList, len) {\n  let currLen = 0;\n  const currentNodeList = [];\n  for (let i = 0; i < nodeList.length; i += 1) {\n    // Match to return\n    if (currLen === len) {\n      return currentNodeList;\n    }\n    const node = nodeList[i];\n    const canCut = cuttable(node);\n    const nodeLen = canCut ? String(node).length : 1;\n    const nextLen = currLen + nodeLen;\n    // Exceed but current not which means we need cut this\n    // This will not happen on validate ReactElement\n    if (nextLen > len) {\n      const restLen = len - currLen;\n      currentNodeList.push(String(node).slice(0, restLen));\n      return currentNodeList;\n    }\n    currentNodeList.push(node);\n    currLen = nextLen;\n  }\n  return nodeList;\n}\n// Measure for the `text` is exceed the `rows` or not\nconst STATUS_MEASURE_NONE = 0;\nconst STATUS_MEASURE_START = 1;\nconst STATUS_MEASURE_NEED_ELLIPSIS = 2;\nconst STATUS_MEASURE_NO_NEED_ELLIPSIS = 3;\nconst lineClipStyle = {\n  display: '-webkit-box',\n  overflow: 'hidden',\n  WebkitBoxOrient: 'vertical'\n};\nexport default function EllipsisMeasure(props) {\n  _s2();\n  const {\n    enableMeasure,\n    width,\n    text,\n    children,\n    rows,\n    miscDeps,\n    onEllipsis\n  } = props;\n  const nodeList = React.useMemo(() => toArray(text), [text]);\n  const nodeLen = React.useMemo(() => getNodesLen(nodeList), [text]);\n  // ========================= Full Content =========================\n  const fullContent = React.useMemo(() => children(nodeList, false, false), [text]);\n  // ========================= Cut Content ==========================\n  const [ellipsisCutIndex, setEllipsisCutIndex] = React.useState(null);\n  const cutMidRef = React.useRef(null);\n  // ========================= NeedEllipsis =========================\n  const needEllipsisRef = React.useRef(null);\n  const [needEllipsis, setNeedEllipsis] = React.useState(STATUS_MEASURE_NONE);\n  const [ellipsisHeight, setEllipsisHeight] = React.useState(0);\n  // Trigger start measure\n  useLayoutEffect(() => {\n    if (enableMeasure && width && nodeLen) {\n      setNeedEllipsis(STATUS_MEASURE_START);\n    } else {\n      setNeedEllipsis(STATUS_MEASURE_NONE);\n    }\n  }, [width, text, rows, enableMeasure, nodeList]);\n  // Measure process\n  useLayoutEffect(() => {\n    var _a, _b;\n    if (needEllipsis === STATUS_MEASURE_START) {\n      const isOverflow = !!((_a = needEllipsisRef.current) === null || _a === void 0 ? void 0 : _a.isExceed());\n      setNeedEllipsis(isOverflow ? STATUS_MEASURE_NEED_ELLIPSIS : STATUS_MEASURE_NO_NEED_ELLIPSIS);\n      setEllipsisCutIndex(isOverflow ? [0, nodeLen] : null);\n      // For the accuracy issue, we add 1px to the height\n      setEllipsisHeight((((_b = needEllipsisRef.current) === null || _b === void 0 ? void 0 : _b.getHeight()) || 0) + 1);\n      onEllipsis(isOverflow);\n    }\n  }, [needEllipsis]);\n  // ========================= Cut Measure ==========================\n  const cutMidIndex = ellipsisCutIndex ? Math.ceil((ellipsisCutIndex[0] + ellipsisCutIndex[1]) / 2) : 0;\n  useLayoutEffect(() => {\n    var _a;\n    const [minIndex, maxIndex] = ellipsisCutIndex || [0, 0];\n    if (minIndex !== maxIndex) {\n      const midHeight = ((_a = cutMidRef.current) === null || _a === void 0 ? void 0 : _a.getHeight()) || 0;\n      const isOverflow = midHeight > ellipsisHeight;\n      let targetMidIndex = cutMidIndex;\n      if (maxIndex - minIndex === 1) {\n        targetMidIndex = isOverflow ? minIndex : maxIndex;\n      }\n      if (isOverflow) {\n        setEllipsisCutIndex([minIndex, targetMidIndex]);\n      } else {\n        setEllipsisCutIndex([targetMidIndex, maxIndex]);\n      }\n    }\n  }, [ellipsisCutIndex, cutMidIndex]);\n  // ========================= Text Content =========================\n  const finalContent = React.useMemo(() => {\n    if (needEllipsis !== STATUS_MEASURE_NEED_ELLIPSIS || !ellipsisCutIndex || ellipsisCutIndex[0] !== ellipsisCutIndex[1]) {\n      const content = children(nodeList, false, false);\n      // Limit the max line count to avoid scrollbar blink\n      // https://github.com/ant-design/ant-design/issues/42958\n      if (needEllipsis !== STATUS_MEASURE_NO_NEED_ELLIPSIS && needEllipsis !== STATUS_MEASURE_NONE) {\n        return /*#__PURE__*/React.createElement(\"span\", {\n          style: Object.assign(Object.assign({}, lineClipStyle), {\n            WebkitLineClamp: rows\n          })\n        }, content);\n      }\n      return content;\n    }\n    return children(sliceNodes(nodeList, ellipsisCutIndex[0]), true, true);\n  }, [needEllipsis, ellipsisCutIndex, nodeList].concat(_toConsumableArray(miscDeps)));\n  // ============================ Render ============================\n  const measureStyle = {\n    width,\n    whiteSpace: 'normal',\n    margin: 0,\n    padding: 0\n  };\n  return /*#__PURE__*/React.createElement(React.Fragment, null, finalContent, needEllipsis === STATUS_MEASURE_START && ( /*#__PURE__*/React.createElement(MeasureText, {\n    style: Object.assign(Object.assign(Object.assign({}, measureStyle), lineClipStyle), {\n      WebkitLineClamp: rows\n    }),\n    ref: needEllipsisRef\n  }, fullContent)), needEllipsis === STATUS_MEASURE_NEED_ELLIPSIS && ellipsisCutIndex && ellipsisCutIndex[0] !== ellipsisCutIndex[1] && ( /*#__PURE__*/React.createElement(MeasureText, {\n    style: Object.assign(Object.assign({}, measureStyle), {\n      top: 400\n    }),\n    ref: cutMidRef\n  }, children(sliceNodes(nodeList, cutMidIndex), true, true))));\n}\n_s2(EllipsisMeasure, \"oWEMgBVN2LndfyH+HqVBpP5q6RM=\");\n_c3 = EllipsisMeasure;\nvar _c, _c2, _c3;\n$RefreshReg$(_c, \"MeasureText$React.forwardRef\");\n$RefreshReg$(_c2, \"MeasureText\");\n$RefreshReg$(_c3, \"EllipsisMeasure\");","map":{"version":3,"names":["_s","$RefreshSig$","_s2","_toConsumableArray","React","toArray","useLayoutEffect","MeasureText","forwardRef","_c","_ref","ref","style","children","spanRef","useRef","useImperativeHandle","isExceed","span","current","scrollHeight","clientHeight","getHeight","createElement","Object","assign","position","display","left","top","pointerEvents","backgroundColor","_c2","cuttable","node","type","getNodesLen","nodeList","totalLen","forEach","String","length","sliceNodes","len","currLen","currentNodeList","i","canCut","nodeLen","nextLen","restLen","push","slice","STATUS_MEASURE_NONE","STATUS_MEASURE_START","STATUS_MEASURE_NEED_ELLIPSIS","STATUS_MEASURE_NO_NEED_ELLIPSIS","lineClipStyle","overflow","WebkitBoxOrient","EllipsisMeasure","props","enableMeasure","width","text","rows","miscDeps","onEllipsis","useMemo","fullContent","ellipsisCutIndex","setEllipsisCutIndex","useState","cutMidRef","needEllipsisRef","needEllipsis","setNeedEllipsis","ellipsisHeight","setEllipsisHeight","_a","_b","isOverflow","cutMidIndex","Math","ceil","minIndex","maxIndex","midHeight","targetMidIndex","finalContent","content","WebkitLineClamp","concat","measureStyle","whiteSpace","margin","padding","Fragment","_c3","$RefreshReg$"],"sources":["/Users/jmmallon/Downloads/js/ticketproject/src/node_modules/antd/es/typography/Base/Ellipsis.js"],"sourcesContent":["\"use client\";\n\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport * as React from 'react';\nimport toArray from \"rc-util/es/Children/toArray\";\nimport useLayoutEffect from \"rc-util/es/hooks/useLayoutEffect\";\nconst MeasureText = /*#__PURE__*/React.forwardRef((_ref, ref) => {\n  let {\n    style,\n    children\n  } = _ref;\n  const spanRef = React.useRef(null);\n  React.useImperativeHandle(ref, () => ({\n    isExceed: () => {\n      const span = spanRef.current;\n      return span.scrollHeight > span.clientHeight;\n    },\n    getHeight: () => spanRef.current.clientHeight\n  }));\n  return /*#__PURE__*/React.createElement(\"span\", {\n    \"aria-hidden\": true,\n    ref: spanRef,\n    style: Object.assign({\n      position: 'fixed',\n      display: 'block',\n      left: 0,\n      top: 0,\n      // zIndex: -9999,\n      // visibility: 'hidden',\n      pointerEvents: 'none',\n      backgroundColor: 'rgba(255, 0, 0, 0.65)'\n    }, style)\n  }, children);\n});\nfunction cuttable(node) {\n  const type = typeof node;\n  return type === 'string' || type === 'number';\n}\nfunction getNodesLen(nodeList) {\n  let totalLen = 0;\n  nodeList.forEach(node => {\n    if (cuttable(node)) {\n      totalLen += String(node).length;\n    } else {\n      totalLen += 1;\n    }\n  });\n  return totalLen;\n}\nfunction sliceNodes(nodeList, len) {\n  let currLen = 0;\n  const currentNodeList = [];\n  for (let i = 0; i < nodeList.length; i += 1) {\n    // Match to return\n    if (currLen === len) {\n      return currentNodeList;\n    }\n    const node = nodeList[i];\n    const canCut = cuttable(node);\n    const nodeLen = canCut ? String(node).length : 1;\n    const nextLen = currLen + nodeLen;\n    // Exceed but current not which means we need cut this\n    // This will not happen on validate ReactElement\n    if (nextLen > len) {\n      const restLen = len - currLen;\n      currentNodeList.push(String(node).slice(0, restLen));\n      return currentNodeList;\n    }\n    currentNodeList.push(node);\n    currLen = nextLen;\n  }\n  return nodeList;\n}\n// Measure for the `text` is exceed the `rows` or not\nconst STATUS_MEASURE_NONE = 0;\nconst STATUS_MEASURE_START = 1;\nconst STATUS_MEASURE_NEED_ELLIPSIS = 2;\nconst STATUS_MEASURE_NO_NEED_ELLIPSIS = 3;\nconst lineClipStyle = {\n  display: '-webkit-box',\n  overflow: 'hidden',\n  WebkitBoxOrient: 'vertical'\n};\nexport default function EllipsisMeasure(props) {\n  const {\n    enableMeasure,\n    width,\n    text,\n    children,\n    rows,\n    miscDeps,\n    onEllipsis\n  } = props;\n  const nodeList = React.useMemo(() => toArray(text), [text]);\n  const nodeLen = React.useMemo(() => getNodesLen(nodeList), [text]);\n  // ========================= Full Content =========================\n  const fullContent = React.useMemo(() => children(nodeList, false, false), [text]);\n  // ========================= Cut Content ==========================\n  const [ellipsisCutIndex, setEllipsisCutIndex] = React.useState(null);\n  const cutMidRef = React.useRef(null);\n  // ========================= NeedEllipsis =========================\n  const needEllipsisRef = React.useRef(null);\n  const [needEllipsis, setNeedEllipsis] = React.useState(STATUS_MEASURE_NONE);\n  const [ellipsisHeight, setEllipsisHeight] = React.useState(0);\n  // Trigger start measure\n  useLayoutEffect(() => {\n    if (enableMeasure && width && nodeLen) {\n      setNeedEllipsis(STATUS_MEASURE_START);\n    } else {\n      setNeedEllipsis(STATUS_MEASURE_NONE);\n    }\n  }, [width, text, rows, enableMeasure, nodeList]);\n  // Measure process\n  useLayoutEffect(() => {\n    var _a, _b;\n    if (needEllipsis === STATUS_MEASURE_START) {\n      const isOverflow = !!((_a = needEllipsisRef.current) === null || _a === void 0 ? void 0 : _a.isExceed());\n      setNeedEllipsis(isOverflow ? STATUS_MEASURE_NEED_ELLIPSIS : STATUS_MEASURE_NO_NEED_ELLIPSIS);\n      setEllipsisCutIndex(isOverflow ? [0, nodeLen] : null);\n      // For the accuracy issue, we add 1px to the height\n      setEllipsisHeight((((_b = needEllipsisRef.current) === null || _b === void 0 ? void 0 : _b.getHeight()) || 0) + 1);\n      onEllipsis(isOverflow);\n    }\n  }, [needEllipsis]);\n  // ========================= Cut Measure ==========================\n  const cutMidIndex = ellipsisCutIndex ? Math.ceil((ellipsisCutIndex[0] + ellipsisCutIndex[1]) / 2) : 0;\n  useLayoutEffect(() => {\n    var _a;\n    const [minIndex, maxIndex] = ellipsisCutIndex || [0, 0];\n    if (minIndex !== maxIndex) {\n      const midHeight = ((_a = cutMidRef.current) === null || _a === void 0 ? void 0 : _a.getHeight()) || 0;\n      const isOverflow = midHeight > ellipsisHeight;\n      let targetMidIndex = cutMidIndex;\n      if (maxIndex - minIndex === 1) {\n        targetMidIndex = isOverflow ? minIndex : maxIndex;\n      }\n      if (isOverflow) {\n        setEllipsisCutIndex([minIndex, targetMidIndex]);\n      } else {\n        setEllipsisCutIndex([targetMidIndex, maxIndex]);\n      }\n    }\n  }, [ellipsisCutIndex, cutMidIndex]);\n  // ========================= Text Content =========================\n  const finalContent = React.useMemo(() => {\n    if (needEllipsis !== STATUS_MEASURE_NEED_ELLIPSIS || !ellipsisCutIndex || ellipsisCutIndex[0] !== ellipsisCutIndex[1]) {\n      const content = children(nodeList, false, false);\n      // Limit the max line count to avoid scrollbar blink\n      // https://github.com/ant-design/ant-design/issues/42958\n      if (needEllipsis !== STATUS_MEASURE_NO_NEED_ELLIPSIS && needEllipsis !== STATUS_MEASURE_NONE) {\n        return /*#__PURE__*/React.createElement(\"span\", {\n          style: Object.assign(Object.assign({}, lineClipStyle), {\n            WebkitLineClamp: rows\n          })\n        }, content);\n      }\n      return content;\n    }\n    return children(sliceNodes(nodeList, ellipsisCutIndex[0]), true, true);\n  }, [needEllipsis, ellipsisCutIndex, nodeList].concat(_toConsumableArray(miscDeps)));\n  // ============================ Render ============================\n  const measureStyle = {\n    width,\n    whiteSpace: 'normal',\n    margin: 0,\n    padding: 0\n  };\n  return /*#__PURE__*/React.createElement(React.Fragment, null, finalContent, needEllipsis === STATUS_MEASURE_START && ( /*#__PURE__*/React.createElement(MeasureText, {\n    style: Object.assign(Object.assign(Object.assign({}, measureStyle), lineClipStyle), {\n      WebkitLineClamp: rows\n    }),\n    ref: needEllipsisRef\n  }, fullContent)), needEllipsis === STATUS_MEASURE_NEED_ELLIPSIS && ellipsisCutIndex && ellipsisCutIndex[0] !== ellipsisCutIndex[1] && ( /*#__PURE__*/React.createElement(MeasureText, {\n    style: Object.assign(Object.assign({}, measureStyle), {\n      top: 400\n    }),\n    ref: cutMidRef\n  }, children(sliceNodes(nodeList, cutMidIndex), true, true))));\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}