{"ast":null,"code":"\"use client\";import _toConsumableArray from\"@babel/runtime/helpers/esm/toConsumableArray\";import*as React from'react';import toArray from\"rc-util/es/Children/toArray\";import useLayoutEffect from\"rc-util/es/hooks/useLayoutEffect\";const MeasureText=/*#__PURE__*/React.forwardRef((_ref,ref)=>{let{style,children}=_ref;const spanRef=React.useRef(null);React.useImperativeHandle(ref,()=>({isExceed:()=>{const span=spanRef.current;return span.scrollHeight>span.clientHeight;},getHeight:()=>spanRef.current.clientHeight}));return/*#__PURE__*/React.createElement(\"span\",{\"aria-hidden\":true,ref:spanRef,style:Object.assign({position:'fixed',display:'block',left:0,top:0,// zIndex: -9999,\n// visibility: 'hidden',\npointerEvents:'none',backgroundColor:'rgba(255, 0, 0, 0.65)'},style)},children);});function cuttable(node){const type=typeof node;return type==='string'||type==='number';}function getNodesLen(nodeList){let totalLen=0;nodeList.forEach(node=>{if(cuttable(node)){totalLen+=String(node).length;}else{totalLen+=1;}});return totalLen;}function sliceNodes(nodeList,len){let currLen=0;const currentNodeList=[];for(let i=0;i<nodeList.length;i+=1){// Match to return\nif(currLen===len){return currentNodeList;}const node=nodeList[i];const canCut=cuttable(node);const nodeLen=canCut?String(node).length:1;const nextLen=currLen+nodeLen;// Exceed but current not which means we need cut this\n// This will not happen on validate ReactElement\nif(nextLen>len){const restLen=len-currLen;currentNodeList.push(String(node).slice(0,restLen));return currentNodeList;}currentNodeList.push(node);currLen=nextLen;}return nodeList;}// Measure for the `text` is exceed the `rows` or not\nconst STATUS_MEASURE_NONE=0;const STATUS_MEASURE_START=1;const STATUS_MEASURE_NEED_ELLIPSIS=2;const STATUS_MEASURE_NO_NEED_ELLIPSIS=3;const lineClipStyle={display:'-webkit-box',overflow:'hidden',WebkitBoxOrient:'vertical'};export default function EllipsisMeasure(props){const{enableMeasure,width,text,children,rows,miscDeps,onEllipsis}=props;const nodeList=React.useMemo(()=>toArray(text),[text]);const nodeLen=React.useMemo(()=>getNodesLen(nodeList),[text]);// ========================= Full Content =========================\nconst fullContent=React.useMemo(()=>children(nodeList,false,false),[text]);// ========================= Cut Content ==========================\nconst[ellipsisCutIndex,setEllipsisCutIndex]=React.useState(null);const cutMidRef=React.useRef(null);// ========================= NeedEllipsis =========================\nconst needEllipsisRef=React.useRef(null);const[needEllipsis,setNeedEllipsis]=React.useState(STATUS_MEASURE_NONE);const[ellipsisHeight,setEllipsisHeight]=React.useState(0);// Trigger start measure\nuseLayoutEffect(()=>{if(enableMeasure&&width&&nodeLen){setNeedEllipsis(STATUS_MEASURE_START);}else{setNeedEllipsis(STATUS_MEASURE_NONE);}},[width,text,rows,enableMeasure,nodeList]);// Measure process\nuseLayoutEffect(()=>{var _a,_b;if(needEllipsis===STATUS_MEASURE_START){const isOverflow=!!((_a=needEllipsisRef.current)===null||_a===void 0?void 0:_a.isExceed());setNeedEllipsis(isOverflow?STATUS_MEASURE_NEED_ELLIPSIS:STATUS_MEASURE_NO_NEED_ELLIPSIS);setEllipsisCutIndex(isOverflow?[0,nodeLen]:null);// For the accuracy issue, we add 1px to the height\nsetEllipsisHeight((((_b=needEllipsisRef.current)===null||_b===void 0?void 0:_b.getHeight())||0)+1);onEllipsis(isOverflow);}},[needEllipsis]);// ========================= Cut Measure ==========================\nconst cutMidIndex=ellipsisCutIndex?Math.ceil((ellipsisCutIndex[0]+ellipsisCutIndex[1])/2):0;useLayoutEffect(()=>{var _a;const[minIndex,maxIndex]=ellipsisCutIndex||[0,0];if(minIndex!==maxIndex){const midHeight=((_a=cutMidRef.current)===null||_a===void 0?void 0:_a.getHeight())||0;const isOverflow=midHeight>ellipsisHeight;let targetMidIndex=cutMidIndex;if(maxIndex-minIndex===1){targetMidIndex=isOverflow?minIndex:maxIndex;}if(isOverflow){setEllipsisCutIndex([minIndex,targetMidIndex]);}else{setEllipsisCutIndex([targetMidIndex,maxIndex]);}}},[ellipsisCutIndex,cutMidIndex]);// ========================= Text Content =========================\nconst finalContent=React.useMemo(()=>{if(needEllipsis!==STATUS_MEASURE_NEED_ELLIPSIS||!ellipsisCutIndex||ellipsisCutIndex[0]!==ellipsisCutIndex[1]){const content=children(nodeList,false,false);// Limit the max line count to avoid scrollbar blink\n// https://github.com/ant-design/ant-design/issues/42958\nif(needEllipsis!==STATUS_MEASURE_NO_NEED_ELLIPSIS&&needEllipsis!==STATUS_MEASURE_NONE){return/*#__PURE__*/React.createElement(\"span\",{style:Object.assign(Object.assign({},lineClipStyle),{WebkitLineClamp:rows})},content);}return content;}return children(sliceNodes(nodeList,ellipsisCutIndex[0]),true,true);},[needEllipsis,ellipsisCutIndex,nodeList].concat(_toConsumableArray(miscDeps)));// ============================ Render ============================\nconst measureStyle={width,whiteSpace:'normal',margin:0,padding:0};return/*#__PURE__*/React.createElement(React.Fragment,null,finalContent,needEllipsis===STATUS_MEASURE_START&&(/*#__PURE__*/React.createElement(MeasureText,{style:Object.assign(Object.assign(Object.assign({},measureStyle),lineClipStyle),{WebkitLineClamp:rows}),ref:needEllipsisRef},fullContent)),needEllipsis===STATUS_MEASURE_NEED_ELLIPSIS&&ellipsisCutIndex&&ellipsisCutIndex[0]!==ellipsisCutIndex[1]&&(/*#__PURE__*/React.createElement(MeasureText,{style:Object.assign(Object.assign({},measureStyle),{top:400}),ref:cutMidRef},children(sliceNodes(nodeList,cutMidIndex),true,true))));}","map":{"version":3,"names":["_toConsumableArray","React","toArray","useLayoutEffect","MeasureText","forwardRef","_ref","ref","style","children","spanRef","useRef","useImperativeHandle","isExceed","span","current","scrollHeight","clientHeight","getHeight","createElement","Object","assign","position","display","left","top","pointerEvents","backgroundColor","cuttable","node","type","getNodesLen","nodeList","totalLen","forEach","String","length","sliceNodes","len","currLen","currentNodeList","i","canCut","nodeLen","nextLen","restLen","push","slice","STATUS_MEASURE_NONE","STATUS_MEASURE_START","STATUS_MEASURE_NEED_ELLIPSIS","STATUS_MEASURE_NO_NEED_ELLIPSIS","lineClipStyle","overflow","WebkitBoxOrient","EllipsisMeasure","props","enableMeasure","width","text","rows","miscDeps","onEllipsis","useMemo","fullContent","ellipsisCutIndex","setEllipsisCutIndex","useState","cutMidRef","needEllipsisRef","needEllipsis","setNeedEllipsis","ellipsisHeight","setEllipsisHeight","_a","_b","isOverflow","cutMidIndex","Math","ceil","minIndex","maxIndex","midHeight","targetMidIndex","finalContent","content","WebkitLineClamp","concat","measureStyle","whiteSpace","margin","padding","Fragment"],"sources":["/Users/jmmallon/Downloads/js/ticketproject/src/node_modules/antd/es/typography/Base/Ellipsis.js"],"sourcesContent":["\"use client\";\n\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport * as React from 'react';\nimport toArray from \"rc-util/es/Children/toArray\";\nimport useLayoutEffect from \"rc-util/es/hooks/useLayoutEffect\";\nconst MeasureText = /*#__PURE__*/React.forwardRef((_ref, ref) => {\n  let {\n    style,\n    children\n  } = _ref;\n  const spanRef = React.useRef(null);\n  React.useImperativeHandle(ref, () => ({\n    isExceed: () => {\n      const span = spanRef.current;\n      return span.scrollHeight > span.clientHeight;\n    },\n    getHeight: () => spanRef.current.clientHeight\n  }));\n  return /*#__PURE__*/React.createElement(\"span\", {\n    \"aria-hidden\": true,\n    ref: spanRef,\n    style: Object.assign({\n      position: 'fixed',\n      display: 'block',\n      left: 0,\n      top: 0,\n      // zIndex: -9999,\n      // visibility: 'hidden',\n      pointerEvents: 'none',\n      backgroundColor: 'rgba(255, 0, 0, 0.65)'\n    }, style)\n  }, children);\n});\nfunction cuttable(node) {\n  const type = typeof node;\n  return type === 'string' || type === 'number';\n}\nfunction getNodesLen(nodeList) {\n  let totalLen = 0;\n  nodeList.forEach(node => {\n    if (cuttable(node)) {\n      totalLen += String(node).length;\n    } else {\n      totalLen += 1;\n    }\n  });\n  return totalLen;\n}\nfunction sliceNodes(nodeList, len) {\n  let currLen = 0;\n  const currentNodeList = [];\n  for (let i = 0; i < nodeList.length; i += 1) {\n    // Match to return\n    if (currLen === len) {\n      return currentNodeList;\n    }\n    const node = nodeList[i];\n    const canCut = cuttable(node);\n    const nodeLen = canCut ? String(node).length : 1;\n    const nextLen = currLen + nodeLen;\n    // Exceed but current not which means we need cut this\n    // This will not happen on validate ReactElement\n    if (nextLen > len) {\n      const restLen = len - currLen;\n      currentNodeList.push(String(node).slice(0, restLen));\n      return currentNodeList;\n    }\n    currentNodeList.push(node);\n    currLen = nextLen;\n  }\n  return nodeList;\n}\n// Measure for the `text` is exceed the `rows` or not\nconst STATUS_MEASURE_NONE = 0;\nconst STATUS_MEASURE_START = 1;\nconst STATUS_MEASURE_NEED_ELLIPSIS = 2;\nconst STATUS_MEASURE_NO_NEED_ELLIPSIS = 3;\nconst lineClipStyle = {\n  display: '-webkit-box',\n  overflow: 'hidden',\n  WebkitBoxOrient: 'vertical'\n};\nexport default function EllipsisMeasure(props) {\n  const {\n    enableMeasure,\n    width,\n    text,\n    children,\n    rows,\n    miscDeps,\n    onEllipsis\n  } = props;\n  const nodeList = React.useMemo(() => toArray(text), [text]);\n  const nodeLen = React.useMemo(() => getNodesLen(nodeList), [text]);\n  // ========================= Full Content =========================\n  const fullContent = React.useMemo(() => children(nodeList, false, false), [text]);\n  // ========================= Cut Content ==========================\n  const [ellipsisCutIndex, setEllipsisCutIndex] = React.useState(null);\n  const cutMidRef = React.useRef(null);\n  // ========================= NeedEllipsis =========================\n  const needEllipsisRef = React.useRef(null);\n  const [needEllipsis, setNeedEllipsis] = React.useState(STATUS_MEASURE_NONE);\n  const [ellipsisHeight, setEllipsisHeight] = React.useState(0);\n  // Trigger start measure\n  useLayoutEffect(() => {\n    if (enableMeasure && width && nodeLen) {\n      setNeedEllipsis(STATUS_MEASURE_START);\n    } else {\n      setNeedEllipsis(STATUS_MEASURE_NONE);\n    }\n  }, [width, text, rows, enableMeasure, nodeList]);\n  // Measure process\n  useLayoutEffect(() => {\n    var _a, _b;\n    if (needEllipsis === STATUS_MEASURE_START) {\n      const isOverflow = !!((_a = needEllipsisRef.current) === null || _a === void 0 ? void 0 : _a.isExceed());\n      setNeedEllipsis(isOverflow ? STATUS_MEASURE_NEED_ELLIPSIS : STATUS_MEASURE_NO_NEED_ELLIPSIS);\n      setEllipsisCutIndex(isOverflow ? [0, nodeLen] : null);\n      // For the accuracy issue, we add 1px to the height\n      setEllipsisHeight((((_b = needEllipsisRef.current) === null || _b === void 0 ? void 0 : _b.getHeight()) || 0) + 1);\n      onEllipsis(isOverflow);\n    }\n  }, [needEllipsis]);\n  // ========================= Cut Measure ==========================\n  const cutMidIndex = ellipsisCutIndex ? Math.ceil((ellipsisCutIndex[0] + ellipsisCutIndex[1]) / 2) : 0;\n  useLayoutEffect(() => {\n    var _a;\n    const [minIndex, maxIndex] = ellipsisCutIndex || [0, 0];\n    if (minIndex !== maxIndex) {\n      const midHeight = ((_a = cutMidRef.current) === null || _a === void 0 ? void 0 : _a.getHeight()) || 0;\n      const isOverflow = midHeight > ellipsisHeight;\n      let targetMidIndex = cutMidIndex;\n      if (maxIndex - minIndex === 1) {\n        targetMidIndex = isOverflow ? minIndex : maxIndex;\n      }\n      if (isOverflow) {\n        setEllipsisCutIndex([minIndex, targetMidIndex]);\n      } else {\n        setEllipsisCutIndex([targetMidIndex, maxIndex]);\n      }\n    }\n  }, [ellipsisCutIndex, cutMidIndex]);\n  // ========================= Text Content =========================\n  const finalContent = React.useMemo(() => {\n    if (needEllipsis !== STATUS_MEASURE_NEED_ELLIPSIS || !ellipsisCutIndex || ellipsisCutIndex[0] !== ellipsisCutIndex[1]) {\n      const content = children(nodeList, false, false);\n      // Limit the max line count to avoid scrollbar blink\n      // https://github.com/ant-design/ant-design/issues/42958\n      if (needEllipsis !== STATUS_MEASURE_NO_NEED_ELLIPSIS && needEllipsis !== STATUS_MEASURE_NONE) {\n        return /*#__PURE__*/React.createElement(\"span\", {\n          style: Object.assign(Object.assign({}, lineClipStyle), {\n            WebkitLineClamp: rows\n          })\n        }, content);\n      }\n      return content;\n    }\n    return children(sliceNodes(nodeList, ellipsisCutIndex[0]), true, true);\n  }, [needEllipsis, ellipsisCutIndex, nodeList].concat(_toConsumableArray(miscDeps)));\n  // ============================ Render ============================\n  const measureStyle = {\n    width,\n    whiteSpace: 'normal',\n    margin: 0,\n    padding: 0\n  };\n  return /*#__PURE__*/React.createElement(React.Fragment, null, finalContent, needEllipsis === STATUS_MEASURE_START && ( /*#__PURE__*/React.createElement(MeasureText, {\n    style: Object.assign(Object.assign(Object.assign({}, measureStyle), lineClipStyle), {\n      WebkitLineClamp: rows\n    }),\n    ref: needEllipsisRef\n  }, fullContent)), needEllipsis === STATUS_MEASURE_NEED_ELLIPSIS && ellipsisCutIndex && ellipsisCutIndex[0] !== ellipsisCutIndex[1] && ( /*#__PURE__*/React.createElement(MeasureText, {\n    style: Object.assign(Object.assign({}, measureStyle), {\n      top: 400\n    }),\n    ref: cutMidRef\n  }, children(sliceNodes(nodeList, cutMidIndex), true, true))));\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}